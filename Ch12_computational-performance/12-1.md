

<!--
 * @version:
 * @Author:  StevenJokess https://github.com/StevenJokess
 * @Date: 2020-07-13 17:06:51
 * @LastEditors:  StevenJokess https://github.com/StevenJokess
 * @LastEditTime: 2020-08-30 21:26:09
 * @Description:MT, improve
 * @TODO::
 * @Reference:http://preview.d2l.ai/d2l-en/PR-1153/chapter_computational-performance/hybridize.html
-->

# 编译器和解释器

到目前为止，这本书主要关注命令式编程，它使用了诸如 print，+ 或者 if 这样的语句来改变程序的状态。考虑以下简单命令式程序的示例。

TODO:CODE

Python是一个解释性语言。在计算 `fancy_func` 时，它按顺序执行构成函数主体的操作。也就是说，它将计算 `e = add (a，b)` ，并将结果存储为变量 e，从而改变程序的状态。接下来的两个语句 `f = add (c，d)`和 `g = add (e，f)`将以类似的方式执行添加操作，并将结果作为变量存储。图12.1.1显示了数据流。

虽然命令式编程是方便的，但是它可能是低效的。一方面，即使在 `fancy_func` 中反复调用 add 函数，Python 也会分别执行这三个函数调用。如果在一个 GPU 上(甚至在多个 GPU 上)执行这些命令，Python 解释器所产生的开销就会变得非常大。此外，它需要保存 e 和 f 的变量值，直到 fancy_func 中的所有语句都被执行。这是因为我们不知道在执行语句 `e = add (a，b)`和 `f = add (c，d)`之后，程序的其他部分是否会使用变量 `e` 和 `f`。

## 符号式编程

虑另一种方法，即符号编程，其中计算通常只在完全定义了进程之后才执行。这个策略被多个深度学习框架使用，包括 Theano、 Keras 和 TensorFlow (后两个框架已经获得了命令式扩展)。它通常包括以下步骤:

    1. 定义要执行的操作。
    2. 将操作编译成可执行程序。
    3. 提供所需的输入并调用已编译的程序执行。

这允许进行大量的优化。首先，在许多情况下，我们可以跳过 Python 解释器，从而消除一个性能瓶颈，这个瓶颈可能在 CPU 上的一个 Python 线程配对的多个快速 gpu 上变得非常重要。其次，编译器可能会优化并重写上面的代码到 `print ((1 + 2) + (3 + 4))` ，甚至 `print (10)`。这是可能的，因为编译器在将代码转换成机器指令之前可以看到完整的代码。例如，只要不再需要某个变量，它就可以释放内存(或者永远不分配内存)。或者，它可以将代码完全转换为等价的片段。为了得到一个更好的想法，可以考虑下面的命令式编程模拟(毕竟它是 Python)。

TODO:CODE

命令式（解释性）编程和符号式编程之间的区别如下：

* 命令式编程更容易。当在Python中使用命令式编程时，大多数代码都简单明了且易于编写。调试命令性编程代码也更加容易。这是因为更容易获得和打印所有相关的中间变量值，或使用Python的内置调试工具。
* 符号编程更有效且更容易移植。它使得在编译过程中优化代码变得更加容易，同时还具有将程序移植为独立于Python的格式的能力。这允许程序在非Python环境中运行，从而避免了与Python解释器有关的任何潜在性能问题。

## 混合编程

历史上，大多数深度学习框架都在命令式或符号式方法之间进行选择。例如，Theano，TensorFlow（受后者启发），Keras和CNTK象征性地建立模型。相反，Chainer和PyTorch采用命令式方法。在以后的版本中，命令模式已添加到TensorFlow 2.0（通过Eager）和Keras中。在设计Gluon时，开发人员考虑了是否有可能将两种编程模型的优点结合在一起。这导致了一种混合模型，该模型允许用户使用纯命令式编程进行开发和调试，同时能够在需要产品级计算性能和部署时将大多数程序转换为符号程序以运行。

实际上，这意味着我们使用`HybridBlock`或`HybridSequential`和`HybridConcurrent`类构建模型。默认情况下，它们以与命令式编程中执行`Block`或`Sequential`和`Concurrent`类相同的方式执行。`HybridSequential`是`HybridBlock`的子类（就像`Sequential`子类`Block`一样）。当调用`hybridize`函数时，Gluon将模型编译为符号编程中使用的形式。这使人们可以优化计算密集型组件，而无需牺牲实现模型的方式。我们将在下面说明好处，仅关注顺序模型和块（并发组合的工作方式类似）。

## 混合连续的

感受混合工作方式的最简单方法是考虑具有多层的深度网络。按照惯例，Python解释器将需要为所有层执行代码以生成一条指令，然后将其转发到CPU或GPU。对于单个（快速）计算设备，这不会引起任何重大问题。另一方面，如果我们使用高级的8-GPU服务器（例如AWS P3dn.24xlarge实例），Python将很难使所有GPU繁忙。单线程Python解释器成为这里的瓶颈。让我们看看如何通过用HybridSequential替换Sequential来解决代码的重要部分。我们首先定义一个简单的MLP。

TODO:CODE

通过调用`hybridize`函数，我们可以编译和优化MLP中的计算。模型的计算结果保持不变。

TODO:CODE

这似乎太好了，难以置信：只需将一个块指定为`HybridSequential`，编写与以前相同的代码，然后调用`hybridize`。一旦发生这种情况，就会对网络进行优化（我们将在下面对性能进行基准测试）。不幸的是，这并非对每个图层都有效。也就是说，Gluon提供的块在默认情况下是`HybridBlock`的子类，因此是可混合的。如果某个图层继承自`Block`，则不会对其进行优化。

## 被混合加速

为了证明通过编译获得的性能改进，我们比较了杂交前后评估net（x）所需的时间。让我们定义一个函数来首先测量该时间。在我们着手测量（和改进）性能时，它将在本章中变得非常方便。

TODO:CODE

现在，我们可以调用网络两次，一次调用一次，一次不进行杂交。

TODO:CODE

从以上结果可以看出，在HybridSequential实例调用hybridize函数之后，通过使用符号编程可以提高计算性能。

### 序列化

编译模型的好处之一是我们可以将模型及其参数序列化（保存）到磁盘。这使我们能够以与所选择的前端语言无关的方式存储模型。这使我们可以将训练有素的模型部署到其他设备，并轻松使用其他前端编程语言。同时，代码通常比命令式编程所能达到的更快。让我们看看实际的导出方法。

TODO:CODE

该模型被分解成一个（大二进制文件）参数文件和一个执行该模型所需的程序的JSON描述。可以使用Python或MXNet支持的其他前端语言（例如C ++，R，Scala和Perl）读取文件。让我们看一下模型描述。

TODO:CODE

与需要使用forward函数的Block实例相反，对于HybridBlock实例，我们需要使用hybrid_forward函数。

先前，我们证明了在调用hybrid方法之后，该模型能够实现出色的计算性能和可移植性。请注意，尽管杂交会影响模型的灵活性，尤其是在控制流程方面。我们将说明如何设计更通用的模型，以及如何编译将删除虚假的Python元素。

TODO:CODE

上面的代码实现了一个简单的网络，其中包含4个隐藏单元和2个输出。hybrid_forward带有一个附加参数-模块F。这是必需的，因为根据代码是否已混合，它将使用稍有不同的库（ndarray或符号）进行处理。这两个类执行非常相似的功能，并且MXNet自动确定参数。为了了解发生了什么，我们将参数作为函数调用的一部分进行打印。

TODO:CODE

重复正向计算将得到相同的输出（我们省略了详细信息）。现在让我们看看如果调用hybridize方法会发生什么。

TODO:CODE

不使用ndarray，我们现在使用f的符号模块。此外，即使输入是ndarray类型，流经网络的数据现在在编译过程中被转换为符号类型。重复函数调用会导致一个令人惊讶的结果:

TODO:CODE

这和我们之前看到的有很大的不同。将省略在`hybrid_forward`中定义的所有打印语句。实际上，杂交之后，net(x)的执行不再涉及Python解释器。这意味着省略了任何虚假的Python代码(比如print语句)，以便实现更流畅的执行和更好的性能。相反，MXNet直接调用c++后端。还要注意的是，符号模块不支持一些函数(如asnumpy)，而像a += b和a[:] = a + b这样的就地操作必须重写为a = a + b。根据模型的复杂性、CPU的速度以及gpu的速度和数量，这些好处从很小的百分点到超过速度的两倍不等。

## 小结

* 命令式编程使设计新模型变得容易，因为可以使用控制流编写代码，并且能够使用大量Python软件生态系统。
* 符号编程要求我们在执行程序之前指定程序并编译它。这样做的好处是提高了性能。
* MXNet能够根据需要结合两种方法的优点。
* 由HybridSequential和HybridBlock类构造的模型能够通过调用hybridize方法将命令性程序转换为符号程序。

## 练习

1. 使用`HybridConcurrent`类设计网络。或者，查看具有并行级联的网络（GoogLeNet），以组成一个网络。
2. 在本节中，将`x.asnumpy（`）添加到`HybridNet`类的`hybrid_forward`函数的第一行。执行代码并观察您遇到的错误。为什么会发生？
3. 如果我们在`hybrid_forward`函数中添加控制流，即Python语句if和for，会发生什么？
4. 在前几章中回顾您感兴趣的模型，并使用`HybridBlock`类或`HybridSequential`类来实现它们。
