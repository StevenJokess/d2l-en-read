

<!--
 * @version:
 * @Author:  StevenJokess https://github.com/StevenJokess
 * @Date: 2020-07-29 21:50:57
 * @LastEditors:  StevenJokess https://github.com/StevenJokess
 * @LastEditTime: 2020-08-05 22:33:29
 * @Description:MT
 * @TODO::
 * @Reference:http://preview.d2l.ai/d2l-en/master/chapter_recurrent-modern/beam-search.html
-->

# 束搜索

在第9.7节中，我们讨论了如何使用可变长度的输入和输出序列来训练编码器-解码器。在本节中，我们将介绍如何使用编码器-解码器来预测可变长度的序列。

在9.5节中，当准备训练数据集时，我们通常在每个句子之后附加一个特殊的符号“<eos>”来表示序列的结束。在下面的讨论中，我们将继续使用这个数学符号。为了便于讨论，我们假设解码器的输出是一个文本序列。设输出文本字典YY(包含特殊符号“<eos>”)的大小为|Y||Y|，输出序列的最大长度为T’。可能的输出序列总共有O(|Y|T ')类型。这些输出序列中特殊符号" <eos> "之后的所有子序列都将被丢弃。此外，我们还将上下文向量表示为cc，它对输入的所有隐藏状态信息进行编码。

## 贪心搜索

首先，我们来看看一个简单的解决方案:贪婪搜索。对于输出序列的任意时间步长t'，我们将从|Y|中搜索条件概率最高的单词

作为输出。一旦检测到“<eos>”符号，或者输出序列达到其最大长度T '，则完成输出。

正如我们在讨论解码器时提到的，根据输入序列生成输出序列的条件概率为∏T T ' =1P(yt '∣y1，…，yt '−1,c)，∏T ' =1T ' p (yt '∣y1，…，yt '−1,c)。我们将条件概率最高的输出序列作为最优序列。贪婪搜索的主要问题是不能保证能得到最优序列。

看看下面的例子。我们假设输出字典中有四个单词“A”、“B”、“C”和“<eos>”。图9.8.1中每个时间步长下的4个数字分别表示该时间步长产生“A”、“B”、“C”和“<eos>”的条件概率。在每个时间步长，贪婪搜索选择条件概率最大的词。因此，将生成“A”、“B”、“C”、“<eos>”的输出序列如图9.8.1所示。这个输出序列的条件概率为

图9.8.1每个时间步长下的四个数字分别表示在该时间步长上生成“ A”，“ B”，“ C”和“ <eos>”的条件概率。 在每个时间步，贪婪搜索都会选择条件概率最高的单词。

现在，我们来看图9.8.2所示的另一个例子。 与图9.8.1不同，下图图9.8.2选择单词“ C”，它在时间步长2处具有第二高的条件概率。由于时间步长1和2的输出子序列是时间步长3的基础 从图9.8.1中的“ A”和“ B”变为图9.8.2中的“ A”和“ C”，在时间步骤3生成的每个单词的条件概率在图9.8中也发生了变化。 2。 我们选择条件条件概率最高的单词“ B”。 现在，基于前三个时间步长的时间步长4的输出子序列为“ A”，“ C”和“ B”，与图9.8.1中的“ A”，“ B”和“ C”不同 。 因此，在图9.8.2中的时间步4中生成每个单词的条件概率也与图9.8.1中的条件概率不同。 我们发现当前时间步长的输出序列“ A”，“ C”，“ B”和“ <eos>”的条件概率为0.5×0.3×0.6×0.6 = 0.0540.5×0.3×0.6×0.6 = 0.054，高于贪婪搜索获得的输出序列的条件概率。 因此，通过贪婪搜索获得的输出序列“ A”，“ B”，“ C”和“ <eos>”不是最佳序列。

图9.8.2每个时间步长下的四个数字表示在该时间步长上生成“ A”，“ B”，“ C”和“ <eos>”的条件概率。 在时间步骤2，选择条件第二高的单词“ C”。

## 穷举搜索

如果目标是获得最佳序列，我们可以考虑使用穷举搜索：对所有可能的输出序列的穷举检查，该输出将以最高的条件概率输出序列。

尽管我们可以使用穷举搜索来获得最佳序列，但其计算开销O（| Y | T'）O（| Y | T'）可能过高。 例如，当| Y | = 10000 | Y | = 10000且T'= 10T'= 10时，我们将需要评估1000010 = 10401000010 = 1040序列。 这几乎是不可能完成的。 贪婪搜索的计算开销为O（| Y | T'）O（| Y | T'），通常显着小于穷举搜索的计算开销。 例如，当| Y | = 10000 | Y | = 10000且T'= 10T'= 10时，我们只需要评估10000×10 = 1×10510000×10 = 1×105个序列。

## 波束搜索

波束搜索是一种基于贪心搜索的改进算法。它有一个超参数叫做光束大小，kk。在timestep1，我们选择条件概率最高的kk个单词作为kk候选输出序列的第一个单词。对于后续的每个时间步长，我们将根据前一个时间步长中的kk候选输出序列，从总共的k个|Y|k|Y|可能输出序列中选择条件概率最高的kk输出序列。这些将是该时间步长的候选输出序列。最后，我们将从每个时间步长的候选输出序列中过滤出含有特殊符号“<eos>”的序列，丢弃在它之后的所有子序列，得到最终的候选输出序列集合。

图9.8.3通过一个例子演示了波束搜索的过程。假设输出序列的词汇表只包含5个元素:Y={A,B,C,D,E}Y={A,B,C,D,E}，其中一个是特殊符号“<eos>”。设置波束大小为2，输出序列的最大长度为3。在输出序列的timestep 1，假设条件概率最高的单词P(y1∣c)P(y1∣c)为AA和CC。在时间步2，对于所有的y2∈Y,y2∈Y，我们计算

如果目标是获得最优序列，可以考虑使用穷举搜索:对所有可能的输出序列进行穷举检查，输出条件概率最高的序列。

虽然我们可以使用穷举搜索来获得最优序列，但它的计算开销O(|Y|T ')O(|Y|T ')可能过高。例如，当|Y|=10000|Y|=10000和T ' =10T ' =10时，我们需要计算1000010=10401000010=1040个序列。这几乎是不可能完成的。贪婪搜索的计算开销是O(|Y|T ')O(|Y|T ')，这通常比穷举搜索的计算开销要小得多。例如，当|Y|=10000|Y|=10000, T ' =10T ' =10时，我们只需计算10000×10=1×105个序列。

因此，我们得到6个候选输出序列:(1)A;(2)C;(3) A, B;(4) C、E;(5) A、B、D;(6) C, E, D。最后，我们将根据这6个序列得到最终候选输出序列的集合。

在最终候选输出序列的集合中，我们将取得分最高的序列作为下列序列的输出序列:

TODO:MATH

在这里，L是最终候选序列的长度，而对于suberoom的选择一般为0.75。分母上的L - erm - erm - erm - erm是对上面较长的序列的对数加法分数的惩罚。通过分析得到波束搜索的计算开销O(k|Y|T ')O(k|Y|T ')。其结果介于贪婪搜索和穷举搜索的计算开销之间。此外，贪婪搜索可以被视为波束大小为1的波束搜索。光束搜索利用柔性光束大小的kk在计算开销和搜索质量之间取得了平衡。

## 小结

* 预测变长序列的方法包括贪婪搜索、穷举搜索和波束搜索。
* 光束搜索利用灵活的光束大小在计算开销和搜索质量之间取得平衡。

## 练习

1. 我们能否将穷举搜索看作是具有特殊波束大小的波束搜索?为什么?
1. 在8.5节中，我们使用语言模型来生成句子。这个输出使用哪种类型的搜索?你能改进它吗?
