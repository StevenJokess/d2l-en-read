

<!--
 * @version:
 * @Author:  StevenJokess https://github.com/StevenJokess
 * @Date: 2020-08-15 13:18:12
 * @LastEditors:  StevenJokess https://github.com/StevenJokess
 * @LastEditTime: 2020-08-15 13:36:35
 * @Description:MT
 * @TODO::
 * @Reference:http://preview.d2l.ai/d2l-en/master/chapter_natural-language-processing-pretraining/subword-embedding.html
-->

# 子词嵌入

英语词汇通常具有内部结构和构词方式。例如，我们可以通过“dog”、“dogs”和“ dogcatcher”的拼写来推断它们之间的关系。所有这些词都有相同的词根，“狗” ，但他们使用不同的后缀来改变这个词的意思。此外，这种联想还可以扩展到其他词语。例如，“dog”和“ dogs”之间的关系就像“cat”和“ cats”之间的关系。“boy”与“boyfriend”的关系就像“girl”与“girlfriend”的关系。这种特点并不是英语所独有的。在法语和西班牙语中，许多动词可以根据上下文有40多种不同的形式。在芬兰语中，一个名词可能有15种以上的形式。词法学是语言学的一个重要分支，它研究词的内部结构和构成。

## fastText

在 word2vec 中，我们没有直接使用词法信息。在跳过格拉姆模型和连续词袋模型模型中，我们使用不同的向量来表示不同形式的词。例如，“ dog”和“ dogs”由两个不同的向量表示，而这两个向量之间的关系在模型中没有直接表示。有鉴于此，fastText [ Bojanowski et al. ，2017]提出了子词嵌入的方法，从而试图在 word2vec 中的跳过格模型中引入形态信息。

在 fastText 中，每个中心单词都表示为子单词的集合。下面我们用单词“ where”作为例子来理解子词是如何构成的。首先，我们在单词的开头和结尾添加特殊字符“ < ”和“ > ” ，以区分用作前缀和后缀的子词。然后，我们把词作为一个字符序列来提取 n 个字符。例如，当n = 3时，我们可以得到所有长度为33的子单词:

"<wh", "whe", "her", "ere", "re>",

and the special subword  "<where>" .

在fastText中，对于一个单词ww，我们记录其长度为33到66的所有子词和特殊子词的并集，即GwGw。因此，词典是所有词的子词的集合。假设字典中子词gg的向量为zgzg。那么，跃格模型中单词ww的中心词向量uwuw可以表示为

TODO:MATH

fastText过程的其余部分与skip-gram模型一致，因此在此不再重复。 如我们所见，与skip-gram模型相比，fastText中的字典更大，从而导致更多的模型参数。 而且，一个单词的向量需要所有子单词向量的求和，这导致更高的计算复杂度。 但是，通过查看结构相似的其他单词，我们可以获得更好的矢量，以用于更罕见的复杂单词，甚至是词典中不存在的单词。

## 两字节编码

在fastText中，所有提取的子词必须是指定的长度，比如33到66，因此不能预定义词汇表的大小。为了在固定大小的词汇表中允许可变长度的子词，我们可以应用一种称为字节对编码(BPE)的压缩算法来提取子词[Sennrich et al.， 2015]。

字节对编码对训练数据集执行统计分析，以发现一个单词中的公共符号，例如任意长度的连续字符。从长度为11的符号开始，字节对编码迭代地合并最频繁的连续符号对，从而产生新的更长的符号。注意，为了提高效率，不考虑跨越单词边界的对。最后，我们可以使用这些符号作为子词来分割单词。字节对编码及其变体已被用于流行的自然语言处理预训练模型中的输入表示，如GPT-2 [Radford et al.， 2019]和RoBERTa [Liu et al.， 2019]。在下面，我们将说明字节对编码是如何工作的。

首先，我们将符号的词汇表初始化为所有的英文小写字符、一个特殊的字尾符号‘_’和一个特殊的未知符号‘[UNK]’。

由于我们不考虑跨越单词边界的符号对，因此我们只需要一个字典`raw_token_freqs`即可将单词映射到数据集中它们的频率（出现次数）。 注意，特殊符号“_”被附加到每个单词上，以便我们可以轻松地从一系列输出符号（例如“ a_tall er_man”）中恢复单词序列（例如“ a higher man”）。 由于我们是从仅单个字符和特殊符号的词汇表开始合并过程的，因此在每个单词（字典`token_freqs`的键）中的每对连续字符之间插入空格。 换句话说，空格是单词内符号之间的分隔符。

TODO:CODE

我们定义以下`get_max_freq_pair`函数，它返回一个单词中出现频率最高的连续符号对，其中单词来自输入字典`token_freqs`的键。

TODO:CODE

字节对编码是一种基于连续符号频率的贪婪方法，它使用下面的`merge_symbols`函数将出现频率最高的连续符号对合并，生成新的符号。

TODO:CODE

现在我们迭代地在字典`token_freqs`的键上执行字节对编码算法。在第一次迭代中，最频繁的一对连续符号是`“t”`和“a”，因此字节对编码将它们合并成一个新的符号“ta”。在第二次迭代中，字节对编码继续合并`'ta'`和`'l'`以产生另一个新符号'tal'。

TODO:CODE

在字节对编码的10次迭代之后，我们可以看到列表符号现在包含了10个更多的符号，这些符号是从其他符号迭代合并而来的。

TODO:CODE

对于在字典raw_token_freqs的键中指定的相同数据集，数据集中的每个单词现在都被子词“fast_”、“fast”、“er_”、“tall_”和“tall”分割，这是字节对编码算法的结果。例如，单词“faster_”和“taller_”分别被分割为“faster_”和“taller_”。

TODO:CODE

请注意，字节对编码的结果取决于所使用的数据集。我们还可以使用从一个数据集学到的子词来分割另一个数据集的词。作为一种贪婪的方法，下面的`segment_BPE`函数尝试将单词从输入参数符号中分割成最长的子单词。

TODO:CODE

在下文中，我们使用列表`symblos`中的子词（从前面提到的数据集中学习）来分割代表另一个数据集的`tokens`。

TODO:CODE

## 总结

* FastText提出了一种子词嵌入方法。根据word2vec中的跃格模型，将中心词向量表示为该词的子词向量之和。
* 子词嵌入利用形态学原理，通常可以提高不常见词的表示质量。
* 字节对编码对训练数据集执行统计分析，以发现一个单词内的公共符号。作为一种贪婪的方法，字节对编码迭代地合并最频繁的连续符号对。

## 练习

1. 如果子词太多(例如英语中6个词组成了3×1083×108的组合)，会出现什么问题?你能想出解决它们的方法吗?提示:请参考fastText文件[1]的3.2节的末尾。
1. 如何设计一个基于连续词包模型的子词嵌入模型?
1. 要得到大小为mm的词汇表，当初始符号词汇表的大小为nn时，需要进行多少合并操作?
1. 我们如何扩展字节对编码的思想来提取短语?
